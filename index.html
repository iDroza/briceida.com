<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Typing Effects Lab</title>
<style>
  :root{ --bg:#000; --fg:#fff; --accent:#9900FF; --muted:#666; --border:rgba(255,255,255,.14); }
  html,body{ height:100%; margin:0; background:var(--bg); color:var(--fg);
    font-family:-apple-system,BlinkMacSystemFont,"SF Pro Display","SF Pro Text","Helvetica Neue",Helvetica,Arial,sans-serif;
    font-weight:700; -webkit-font-smoothing:antialiased; overflow:hidden; }
  .wrap{ min-height:100%; display:grid; place-items:center; padding:2rem; text-align:center; }
  .hero{ display:inline-block; border:1px solid var(--border); border-radius:24px;
    padding:clamp(16px,3vw,32px) clamp(18px,4vw,52px); box-shadow:0 10px 30px rgba(0,0,0,.45); }
  .line{ margin:0; letter-spacing:.2px; line-height:1.05; font-size:clamp(28px,6vw,72px); white-space:pre-wrap; }
  .accent{ color:var(--accent); }
  /* Carets */
  .caret{ display:inline-block; width:.6ch; height:1em; background:currentColor; vertical-align:-.08em; }
  .blink { animation: blink 1s steps(1) infinite; }
  @keyframes blink{ 50%{ opacity:0 } }
  .beam { width:2px; transform:translateY(.08em); }
  .underscore { height:2px; width:0.7em; transform:translateY(.45em); }
  /* Control tray */
  .tray{ position:fixed; right:16px; top:16px; display:flex; gap:8px; align-items:center;
    background:rgba(255,255,255,.04); border:1px solid var(--border); border-radius:12px; padding:8px 10px; backdrop-filter:blur(6px); }
  .tray label{ font-size:.8rem; color:#aaa; font-weight:600; }
  .tray select,.tray button{ background:#111; color:#ddd; border:1px solid #2a2a2a; border-radius:8px; padding:6px 8px; font-weight:600; }
  .tray button{ cursor:pointer }
  .hint{ position:fixed; left:16px; bottom:16px; color:#888; font-size:.8rem; letter-spacing:.3px; }
  /* Effects visuals */
  .ghost{ color:var(--muted); opacity:.35; position:absolute; inset:0; pointer-events:none; }
  .glow span.typed { text-shadow:0 0 8px rgba(153,0,255,.35), 0 0 20px rgba(153,0,255,.22); transition:text-shadow .2s ease; }
  .trail span.fade { opacity:.35; }
</style>
</head>
<body>
  <div class="tray">
    <label for="fx">Typing FX</label>
    <select id="fx">
      <option>Classic Typewriter</option>
      <option>Human Jitter</option>
      <option>Mistype & Correct</option>
      <option>Word-by-Word</option>
      <option>Reverse Type</option>
      <option>Center-Out Type</option>
      <option>Ghost Preview Overlay</option>
      <option>Decoder / Scramble</option>
      <option>Slide Caret (beam)</option>
      <option>Underline Caret</option>
      <option>Glow Trail</option>
      <option>Fade Trail</option>
    </select>
    <button id="prev">◀</button>
    <button id="next">▶</button>
    <button id="pause">⏸</button>
  </div>

  <div class="wrap">
    <div class="hero">
      <h1 class="line" id="line"></h1>
      <!-- ghost layer is injected only for the Ghost effect -->
    </div>
  </div>

  <div class="hint">Space = pause/resume · Arrows = prev/next message</div>

<script>
(function(){
  const line = document.getElementById('line');
  const fxSel = document.getElementById('fx');
  const btnPrev = document.getElementById('prev');
  const btnNext = document.getElementById('next');
  const btnPause= document.getElementById('pause');

  // Your messages; accent is rendered purple within the sentence.
  const msgs = [
    {text:`The world is `, accent:`yours`, end:`.`},
    {text:`What are you so `, accent:`afraid`, end:` of?`},
    {text:`Volume Negates `, accent:`Luck`, end:`.`},
    {text:`No hard feelings `, accent:`brother`, end:`.`},
    {text:`Poverty loves `, accent:`balance`, end:`.`},
    {text:`You don't win silver, you `, accent:`lose`, end:` gold.`},
    {text:`Obedience `, accent:`begets`, end:` mediocrity.`},
    {text:`This isn't real, you're `, accent:`dreaming`, end:`.`},
    {text:`I am `, accent:`invincible`, end:`.`}
  ];

  const HOLD = 1100;             // ms to hold before erase
  const TYPE = 55;               // base per-char
  const ERASE = 36;
  const wait = ms => new Promise(r=>setTimeout(r,ms));

  // Build final HTML string with accent span
  function finalHTML(m){ return `${m.text}<span class="accent">${m.accent||""}</span>${m.end||""}`; }
  function plain(m){ return (m.text||"") + (m.accent||"") + (m.end||""); }
  function splitWords(s){ return s.match(/\S+\s*/g) || []; }

  // ---------- EFFECTS (each returns {in(m), out()}) ----------
  const effects = {
    "Classic Typewriter": ()=>{
      return {
        async in(m){
          line.className='line';
          const t = plain(m);
          line.innerHTML = '';
          for (let i=0;i<t.length;i++){
            line.textContent = t.slice(0,i+1);
            line.insertAdjacentHTML('beforeend', `<span class="caret blink"></span>`);
            await wait(TYPE);
          }
          // swap in accent markup
          line.innerHTML = finalHTML(m) + `<span class="caret blink"></span>`;
        },
        async out(){
          let s = line.innerText;
          while(s.length){
            s = s.slice(0,-1);
            line.textContent = s;
            await wait(ERASE);
          }
          line.innerHTML='';
        }
      };
    },

    "Human Jitter": ()=>{
      const jitter = (b)=> b + Math.floor((Math.random()*40)-20);
      return {
        async in(m){
          line.className='line';
          const t = plain(m);
          line.innerHTML='';
          for (let i=0;i<t.length;i++){
            line.textContent = t.slice(0,i+1);
            line.insertAdjacentHTML('beforeend', `<span class="caret blink"></span>`);
            await wait(Math.max(20, jitter(TYPE)));
          }
          line.innerHTML = finalHTML(m) + `<span class="caret blink"></span>`;
        },
        async out(){ await effects["Classic Typewriter"]().out(); }
      };
    },

    "Mistype & Correct": ()=>{
      return {
        async in(m){
          line.className='line';
          const t = plain(m);
          line.innerHTML='';
          let s='';
          for(let i=0;i<t.length;i++){
            // occasional wrong char, then backspace
            if(Math.random()<0.12){
              const wrong = String.fromCharCode(33+Math.floor(Math.random()*60));
              s += wrong; line.textContent = s;
              line.insertAdjacentHTML('beforeend', `<span class="caret blink"></span>`);
              await wait(TYPE*0.9);
              // backspace
              s = s.slice(0,-1); line.textContent = s;
              line.insertAdjacentHTML('beforeend', `<span class="caret blink"></span>`);
              await wait(TYPE*0.7);
            }
            s += t[i]; line.textContent = s;
            line.insertAdjacentHTML('beforeend', `<span class="caret blink"></span>`);
            await wait(TYPE);
          }
          line.innerHTML = finalHTML(m) + `<span class="caret blink"></span>`;
        },
        async out(){ await effects["Classic Typewriter"]().out(); }
      };
    },

    "Word-by-Word": ()=>{
      return {
        async in(m){
          line.className='line';
          const words = splitWords(plain(m));
          line.innerHTML='';
          let s='';
          for(const w of words){
            s += w; line.textContent = s;
            line.insertAdjacentHTML('beforeend', `<span class="caret blink"></span>`);
            await wait(TYPE*2);
          }
          line.innerHTML = finalHTML(m) + `<span class="caret blink"></span>`;
        },
        async out(){ await effects["Classic Typewriter"]().out(); }
      };
    },

    "Reverse Type": ()=>{
      return {
        async in(m){
          line.className='line';
          const t = plain(m);
          for(let i=t.length;i>=0;i--){
            line.textContent = t.slice(i);
            line.insertAdjacentHTML('afterbegin', `<span class="caret blink"></span>`);
            await wait(TYPE*0.8);
          }
          line.innerHTML = finalHTML(m);
        },
        async out(){ await effects["Classic Typewriter"]().out(); }
      };
    },

    "Center-Out Type": ()=>{
      return {
        async in(m){
          line.className='line';
          const t = plain(m);
          const mid = Math.floor(t.length/2);
          let L = mid, R = mid+1;
          function render(L,R){
            const out = t.slice(L,R);
            line.textContent = out;
          }
          render(L,R);
          while(L>0 || R<t.length){
            if(L>0) L--;
            if(R<t.length) R++;
            render(L,R);
            await wait(TYPE*0.65);
          }
          // swap to full with accent
          line.innerHTML = finalHTML(m);
        },
        async out(){ await effects["Classic Typewriter"]().out(); }
      };
    },

    "Ghost Preview Overlay": ()=>{
      let ghost;
      return {
        async in(m){
          line.className='line';
          const t = plain(m);
          // add ghost layer once
          const hero = line.parentElement;
          hero.querySelector('.ghost')?.remove();
          ghost = document.createElement('div');
          ghost.className='ghost';
          ghost.style.font = 'inherit'; ghost.style.textAlign='inherit';
          ghost.textContent = t;
          hero.style.position='relative';
          hero.appendChild(ghost);
          line.innerHTML='';
          for(let i=0;i<t.length;i++){
            line.textContent = t.slice(0,i+1);
            line.insertAdjacentHTML('beforeend', `<span class="caret blink"></span>`);
            await wait(TYPE*0.9);
          }
          line.innerHTML = finalHTML(m) + `<span class="caret blink"></span>`;
        },
        async out(){
          await effects["Classic Typewriter"]().out();
          line.parentElement.querySelector('.ghost')?.remove();
        }
      };
    },

    "Decoder / Scramble": ()=>{
      const chars = "!<>-_\\/[]{}—=+*^?#________";
      return {
        async in(m){
          line.className='line';
          const target = plain(m);
          let out = new Array(target.length).fill('');
          for(let i=0;i<target.length;i++){
            // scramble phase
            for(let k=0;k<6;k++){
              out[i] = chars[Math.floor(Math.random()*chars.length)];
              line.innerHTML = out.join('') + `<span class="caret blink"></span>`;
              await wait(18);
            }
            out[i] = target[i];
            line.innerHTML = out.join('') + `<span class="caret blink"></span>`;
            await wait(24);
          }
          line.innerHTML = finalHTML(m) + `<span class="caret blink"></span>`;
        },
        async out(){ await effects["Classic Typewriter"]().out(); }
      };
    },

    "Slide Caret (beam)": ()=>{
      return {
        async in(m){
          line.className='line';
          const t = plain(m);
          line.textContent = '';
          for(let i=0;i<t.length;i++){
            line.textContent = t.slice(0,i+1);
            // beam caret appended as 2px bar
            line.insertAdjacentHTML('beforeend', `<span class="caret beam blink"></span>`);
            await wait(TYPE*0.85);
          }
          line.innerHTML = finalHTML(m) + `<span class="caret beam blink"></span>`;
        },
        async out(){ await effects["Classic Typewriter"]().out(); }
      };
    },

    "Underline Caret": ()=>{
      return {
        async in(m){
          line.className='line';
          const t = plain(m);
          line.textContent='';
          for(let i=0;i<t.length;i++){
            line.textContent = t.slice(0,i+1);
            line.insertAdjacentHTML('beforeend', `<span class="caret underscore blink"></span>`);
            await wait(TYPE*0.85);
          }
          line.innerHTML = finalHTML(m) + `<span class="caret underscore blink"></span>`;
        },
        async out(){ await effects["Classic Typewriter"]().out(); }
      };
    },

    "Glow Trail": ()=>{
      return {
        async in(m){
          line.className='line glow';
          const t = plain(m);
          line.innerHTML='';
          // build spans to glow per typed char
          for(const ch of t){
            const s = document.createElement('span');
            s.textContent = ch;
            s.style.opacity = 0;
            line.appendChild(s);
          }
          const nodes = Array.from(line.childNodes);
          for(let i=0;i<nodes.length;i++){
            nodes[i].style.opacity = 1;
            nodes[i].classList.add('typed');
            await wait(TYPE*0.85);
          }
          // recolor accent range
          const ai = t.indexOf(m.accent);
          if(ai>=0) for(let j=ai;j<ai+m.accent.length;j++) nodes[j].style.color='var(--accent)';
          line.insertAdjacentHTML('beforeend', `<span class="caret blink"></span>`);
        },
        async out(){ await effects["Classic Typewriter"]().out(); }
      };
    },

    "Fade Trail": ()=>{
      return {
        async in(m){
          line.className='line trail';
          const t = plain(m);
          line.innerHTML='';
          for(const ch of t){
            const s = document.createElement('span');
            s.textContent = ch;
            line.appendChild(s);
            // fade previous char
            const prev = s.previousSibling;
            if(prev && prev.nodeType===1){ prev.classList.add('fade'); }
            await wait(TYPE*0.8);
          }
          // color accent
          const ai = t.indexOf(m.accent);
          if(ai>=0){
            const nodes = Array.from(line.childNodes);
            for(let j=ai;j<ai+m.accent.length;j++) nodes[j].style.color='var(--accent)';
          }
          line.insertAdjacentHTML('beforeend', `<span class="caret blink"></span>`);
        },
        async out(){ await effects["Classic Typewriter"]().out(); }
      };
    },
  };

  // ---------- Runner ----------
  let idx = 0, paused = false;
  let current = effects[fxSel.value]();

  async function typeCycle(){
    while(true){
      if(paused){ await wait(80); continue; }
      const m = msgs[idx % msgs.length];
      await current.in(m);
      if(paused){ await wait(80); continue; }
      await wait(HOLD);
      await current.out();
      idx = (idx+1) % msgs.length;
    }
  }

  fxSel.addEventListener('change', ()=>{ current = effects[fxSel.value](); });
  btnPrev.addEventListener('click', async ()=>{
    if(paused) return; paused=true; btnPause.textContent='▶';
    await current.out(); idx=(idx-1+msgs.length)%msgs.length;
    paused=false; btnPause.textContent='⏸';
  });
  btnNext.addEventListener('click', async ()=>{
    if(paused) return; paused=true; btnPause.textContent='▶';
    await current.out(); idx=(idx+1)%msgs.length;
    paused=false; btnPause.textContent='⏸';
  });
  btnPause.addEventListener('click', ()=>{ paused=!paused; btnPause.textContent = paused?'▶':'⏸'; });
  window.addEventListener('keydown',(e)=>{
    if(e.code==='Space'){ e.preventDefault(); btnPause.click(); }
    if(e.code==='ArrowRight') btnNext.click();
    if(e.code==='ArrowLeft') btnPrev.click();
  });

  (async()=>{ await wait(200); typeCycle(); })();
})();
</script>
</body>
</html>
