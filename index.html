<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Progress Update</title>
  <style>
    :root{
      --bg0:#06050a;
      --bg1:#0d0813;
      --gold:#ffef9a;
    }
    html,body{height:100%; margin:0;}
    body{
      background: radial-gradient(1200px 700px at 50% 30%, var(--bg1), var(--bg0));
      display:flex;
      align-items:center;
      justify-content:center;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: var(--gold);
    }
    .wrap{ width:min(980px, 92vw); }
    h1{
      margin:0 0 10px 0;
      text-align:center;
      font-weight:900;
      text-transform:uppercase;
      letter-spacing:.22em;
      font-size: clamp(18px, 2.4vw, 26px);
      color: var(--gold);
      text-shadow: 0 0 14px rgba(255,239,154,.18);
    }
    .frame{
      border: 1px solid rgba(255,239,154,.18);
      border-radius: 18px;
      padding: 14px;
      background: linear-gradient(180deg, rgba(255,239,154,.05), rgba(0,0,0,.18));
      box-shadow: 0 18px 60px rgba(0,0,0,.55);
    }
    canvas{
      width:100%;
      height:auto;
      aspect-ratio: 16/9;
      display:block;
      border-radius: 14px;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Progress Update</h1>
    <div class="frame">
      <canvas id="c"></canvas>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });
  ctx.imageSmoothingEnabled = false;

  // Pixel-art internal resolution (scaled up by CSS)
  const W = 320;
  const H = 180;
  canvas.width = W;
  canvas.height = H;

  // Boulder stays fixed in screen space.
  const boulder = { x: 204, y: 96, r: 12 };

  // Slope line (mountain boundary): two points
  const A = { x: 52,  y: 150 };  // lower-left
  const B = { x: 286, y: 56  };  // upper-right

  const dx = B.x - A.x;
  const dy = B.y - A.y;
  const len = Math.hypot(dx, dy);
  const tnx = dx / len;   // tangent (up-slope to the right)
  const tny = dy / len;

  // Down-slope direction (treadmill pulls back)
  const dnx = -tnx;
  const dny = -tny;

  // Slope equation: y = m(x - A.x) + A.y
  const m = dy / dx;
  const yAtX = (x) => m * (x - A.x) + A.y;

  // Fast integer hash for texture (deterministic, no flicker)
  function hash2(x, y){
    let n = (x * 374761393) ^ (y * 668265263);
    n = (n ^ (n >>> 13)) * 1274126177;
    return (n ^ (n >>> 16)) >>> 0;
  }

  function putPixel(data, i, r, g, b){
    data[i] = r; data[i+1] = g; data[i+2] = b; data[i+3] = 255;
  }

  function drawScene(timeSec){
    const img = ctx.createImageData(W, H);
    const data = img.data;

    // Treadmill scroll speed (pixels/sec along down-slope)
    const scroll = timeSec * 10.0;

    // Precompute ridge drift along down-slope
    const ox = (dnx * scroll) | 0;
    const oy = (dny * scroll) | 0;

    for(let y=0; y<H; y++){
      // sky gradient-ish
      const skyFade = y / H;
      const skyR = (6 + skyFade * 10) | 0;
      const skyG = (5 + skyFade * 8)  | 0;
      const skyB = (10 + skyFade * 14) | 0;

      for(let x=0; x<W; x++){
        const idx = (y * W + x) * 4;

        const boundary = yAtX(x);

        if(y < boundary){
          // SKY
          // a few ember pixels
          const h = hash2(x, y);
          const ember = ((h & 1023) === 0); // rare
          if(ember){
            putPixel(data, idx, 255, 210, 106);
          } else {
            putPixel(data, idx, skyR, skyG, skyB);
          }
          continue;
        }

        // MOUNTAIN (yellow/orange palette)
        // Depth into mountain from slope line
        const depth = Math.min(1, Math.max(0, (y - boundary) / 60));

        // Sample coords shifted along down-slope => treadmill illusion
        const sx = x + ox;
        const sy = y + oy;

        const h = hash2(sx, sy);
        const n8 = (h & 255); // 0..255

        // Base color by depth
        let r = (255 - depth*90) | 0;   // 255 -> ~165
        let g = (140 - depth*70) | 0;   // 140 -> ~70
        let b = (32  - depth*18) | 0;   // 32  -> ~14

        // Add gritty ruggedness
        if(n8 < 18){         // dark pits
          r = (r * 0.55) | 0; g = (g * 0.50) | 0; b = (b * 0.60) | 0;
        } else if(n8 > 238){ // bright grit
          r = Math.min(255, r + 35);
          g = Math.min(255, g + 45);
          b = Math.min(255, b + 30);
        }

        // Ridge lines roughly parallel to slope (use normal coordinate)
        // normal vector approx perpendicular to slope: ( -tny, tnx )
        const nx = -tny, ny = tnx;
        const normalCoord = ((x*nx + y*ny) * 3) | 0;
        const ridge = Math.abs(((normalCoord + (scroll*3)|0) % 28)) === 0;
        if(ridge){
          r = Math.min(255, r + 22);
          g = Math.min(255, g + 26);
          b = Math.min(255, b + 10);
        }

        // Slight highlight near the slope edge (gives crisp plane)
        if(y - boundary < 2){
          r = Math.min(255, r + 30);
          g = Math.min(255, g + 35);
          b = Math.min(255, b + 12);
        }

        putPixel(data, idx, r, g, b);
      }
    }

    ctx.putImageData(img, 0, 0);

    // Draw the slope "edge" pixels for clarity
    ctx.fillStyle = "rgba(255,239,154,0.75)";
    for(let i=0;i<220;i++){
      const t = i/219;
      const x = (A.x + dx*t) | 0;
      const y = (A.y + dy*t) | 0;
      if(i%2===0) ctx.fillRect(x, y, 1, 1);
    }
  }

  // Rugged boulder edge profile (stable)
  const rough = Array.from({length:28}, (_,i)=>{
    const r = Math.sin(i*2.0)*0.9 + Math.sin(i*0.65)*0.6;
    return r;
  });

  function drawBoulder(x,y,r,spin){
    // Rugged pixel boulder; mostly yellow/orange, sharp edges
    for(let py=-r-2; py<=r+2; py++){
      for(let px=-r-2; px<=r+2; px++){
        const d = Math.hypot(px,py);
        const ang = Math.atan2(py,px) + spin;
        const idx = (((ang + Math.PI) / (2*Math.PI)) * rough.length) | 0;
        const edge = r + rough[(idx + rough.length) % rough.length];
        if(d <= edge){
          // Lighting: brighter top-left
          const lit = (-(px) + -(py)) * 0.05;
          const base = Math.max(0.15, Math.min(0.95, 0.55 + lit));
          const bright = base > 0.58;

          ctx.fillStyle = bright ? "rgba(255,210,106,0.92)" : "rgba(198,122,26,0.98)";
          ctx.fillRect((x+px)|0, (y+py)|0, 1, 1);
        }
      }
    }
    // Shadow under boulder
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    for(let i=0;i<r*2;i++){
      ctx.fillRect((x-r+i)|0, (y+r+2)|0, 1, 1);
    }
  }

  function drawSisyphus(timeSec){
    // He stays “stuck” behind the boulder. Only limbs cycle.
    const step = Math.sin(timeSec * 1.5);        // leg alternation
    const strain = 0.5 + 0.5*Math.sin(timeSec*0.8); // slow effort pulse
    const micro = (Math.sin(timeSec*6.0) * 0.6); // subtle shake (body only)

    // Anchor near boulder
    const ax = (boulder.x - 28) | 0;
    const ay = (boulder.y + 10) | 0;

    // Colors (warm silhouette)
    const skin = "rgba(255,239,154,0.95)";
    const fist = "rgba(255,210,106,0.98)";
    const shade = "rgba(0,0,0,0.25)";

    // Lean into push (slight)
    const leanX = (2 + strain*1) | 0;
    const bobY  = (micro) | 0;

    const bx = ax + leanX;
    const by = ay + bobY;

    // Torso (thicker to feel muscular)
    ctx.fillStyle = skin;
    ctx.fillRect(bx-2, by-12, 5, 9);     // torso/chest
    ctx.fillRect(bx-1, by-16, 3, 4);     // neck

    // Head
    ctx.fillRect(bx-2, by-20, 4, 4);

    // Shoulders
    ctx.fillRect(bx-3, by-13, 7, 2);

    // Arms pushing (animate small piston motion)
    const armPulse = (Math.round((strain - 0.5)*2)) | 0; // -1..1
    const armLen = 7 + armPulse;

    // Front arm to boulder
    ctx.fillRect(bx+2, by-12, armLen, 2);
    // Back arm (shorter, under)
    ctx.fillRect(bx-6, by-11, 6, 2);

    // Big muscular fist on the boulder
    ctx.fillStyle = fist;
    ctx.fillRect(bx+2+armLen, by-13, 3, 3);

    // Legs: alternate forward/back (stepping-in-place)
    ctx.fillStyle = skin;
    const lF = step > 0 ? 1 : -1;
    const lB = -lF;

    // Left leg
    ctx.fillRect(bx-2, by-3, 2, 7);
    ctx.fillRect(bx-2 + lF, by+4, 2, 2);

    // Right leg
    ctx.fillRect(bx+1, by-3, 2, 7);
    ctx.fillRect(bx+1 + lB, by+4, 2, 2);

    // Outline/shadow hints (adds sharpness)
    ctx.fillStyle = shade;
    ctx.fillRect(bx-2, by-12, 1, 9);
    ctx.fillRect(bx-2, by-3, 1, 7);
  }

  const start = performance.now();

  function loop(now){
    const t = (now - start) / 1000;

    // Background treadmill first
    drawScene(t);

    // Boulder stays fixed (no progress), very slight rotation only
    drawBoulder(boulder.x, boulder.y, boulder.r, t*0.35);

    // Sisyphus pushing forever in place
    drawSisyphus(t);

    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
